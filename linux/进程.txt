1 当 一个进程创建时，它几乎与父进程相同。它接收父进程地址空间的一个逻辑拷贝，并从进程创建系统调用的下一条指令开始执行与父进程相同的代码。
尽管父子进程共享含有程序代码的页，但是他们有各自独立的数据拷贝（堆和栈）。因此子进程对一个内存单元的修改对父进程是不可见的。
2 系统管理员可以通过往/proc/sys/kernel/pid_max这个文件中写入值来修改PID的上限
由于循环使用PID编号，内核需要通过管理一个pidmap_array位图来标示当前已分配的PID号和闲置的PID号。
因为一个页框包含32768个位，所以在32位体系结构中pidmap_array位图存放在一个单独的页中

一个线程组中所有的线程使用和该线程组的领头线程相同的PID，也就是该组中第一个轻量级进程的PID，它被存入进程描述符的tgid字段中
getpid系统调用返回当前进程的tgid的值而不是pid的值，因此，一个多线程应用的所有线程共享相同的PID。绝大多数进程都属于一个线程组，包含单一的成员；线程组的
领头线程其tgid的值与pid的值相同，因而getpid系统调用对这类进程所起的作用和一般进程是一样的。
