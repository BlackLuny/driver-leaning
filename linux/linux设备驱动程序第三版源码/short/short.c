/*
 * short.c -- Simple Hardware Operations and Raw Tests
 * short.c -- also a brief example of interrupt handling ("short int")
 *
 * Copyright (C) 2001 Alessandro Rubini and Jonathan Corbet
 * Copyright (C) 2001 O'Reilly & Associates
 *
 * The source code in this file can be freely used, adapted,
 * and redistributed in source or binary form, so long as an
 * acknowledgment appears in derived source files.  The citation
 * should list that the code comes from the book "Linux Device
 * Drivers" by Alessandro Rubini and Jonathan Corbet, published
 * by O'Reilly & Associates.   No warranty is attached;
 * we cannot take responsibility for errors or fitness for use.
 *
 * $Id: short.c,v 1.16 2004/10/29 16:45:40 corbet Exp $
 */

/*
 * FIXME: this driver is not safe with concurrent readers or
 * writers.
 */

#include <linux/config.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

#include <linux/sched.h>
#include <linux/kernel.h>	/* printk() */
#include <linux/fs.h>		/* everything... */
#include <linux/errno.h>	/* error codes */
#include <linux/delay.h>	/* udelay */
#include <linux/kdev_t.h>
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/ioport.h>
#include <linux/interrupt.h>
#include <linux/workqueue.h>
#include <linux/poll.h>
#include <linux/wait.h>

#include <asm/io.h>

#define SHORT_NR_PORTS	8	/* use 8 ports by default */

/*
 * all of the parameters have no "short_" prefix, to save typing when
 * specifying them at load time
 */
static int major = 0;	/* dynamic by default */
module_param(major, int, 0);

static int use_mem = 0;	/* default is I/O-mapped */
module_param(use_mem, int, 0);

/* default is the first printer port on PC's. "short_base" is there too
   because it's what we want to use in the code */
static unsigned long base = 0x378;
unsigned long short_base = 0;
module_param(base, long, 0);

/* The interrupt line is undefined by default. "short_irq" is as above */
static int irq = -1;
volatile int short_irq = -1;
module_param(irq, int, 0);

static int probe = 0;	/* select at load time how to probe irq line */
module_param(probe, int, 0);

static int wq = 0;	/* select at load time whether a workqueue is used */
module_param(wq, int, 0);

static int tasklet = 0;	/* select whether a tasklet is used */
module_param(tasklet, int, 0);

static int share = 0;	/* select at load time whether install a shared irq */
module_param(share, int, 0);

MODULE_AUTHOR ("Alessandro Rubini");
MODULE_LICENSE("Dual BSD/GPL");


unsigned long short_buffer = 0;
unsigned long volatile short_head;
volatile unsigned long short_tail;
DECLARE_WAIT_QUEUE_HEAD(short_queue);

/* Set up our tasklet if we're doing that. */
void short_do_tasklet(unsigned long);
DECLARE_TASKLET(short_tasklet, short_do_tasklet, 0);

/*
 * Atomicly increment an index into short_buffer
 */
static inline void short_incr_bp(volatile unsigned long *index, int delta)
{
	/*
	这个函数非常严谨，他将指针限制在循环缓冲区之内，并且不会因为传递一个不正确的值而返回
	*/
	unsigned long new = *index + delta;
	barrier();  /* 禁止对前后两条语句的优化 */
	*index = (new >= (short_buffer + PAGE_SIZE)) ? short_buffer : new;
}


/*
 * The devices with low minor numbers write/read burst of data to/from
 * specific I/O ports (by default the parallel ones).
 * 
 * The device with 128 as minor number returns ascii strings telling
 * when interrupts have been received. Writing to the device toggles
 * 00/FF on the parallel data lines. If there is a loopback wire, this
 * generates interrupts.  
 */

int short_open (struct inode *inode, struct file *filp)
{
	extern struct file_operations short_i_fops;

	if (iminor (inode) & 0x80)
		filp->f_op = &short_i_fops; /* the interrupt-driven node */
	return 0;
}


int short_release (struct inode *inode, struct file *filp)
{
	return 0;
}


/* first, the port-oriented device */

enum short_modes {SHORT_DEFAULT=0, SHORT_PAUSE, SHORT_STRING, SHORT_MEMORY};

ssize_t do_short_read (struct inode *inode, struct file *filp, char __user *buf,
		size_t count, loff_t *f_pos)
{
	int retval = count, minor = iminor (inode);
	unsigned long port = short_base + (minor&0x0f);
	void *address = (void *) short_base + (minor&0x0f);
	int mode = (minor&0x70) >> 4;
	unsigned char *kbuf = kmalloc(count, GFP_KERNEL), *ptr;
    
	if (!kbuf)
		return -ENOMEM;
	ptr = kbuf;

	if (use_mem)
		mode = SHORT_MEMORY;
	
	switch(mode) {
	    case SHORT_STRING:
		insb(port, ptr, count);
		rmb();
		break;

	    case SHORT_DEFAULT:
		while (count--) {
			*(ptr++) = inb(port);
			rmb();
		}
		break;

	    case SHORT_MEMORY:
		while (count--) {
			*ptr++ = ioread8(address);
			rmb();
		}
		break;
	    case SHORT_PAUSE:
		while (count--) {
			*(ptr++) = inb_p(port);
			rmb();
		}
		break;

	    default: /* no more modes defined by now */
		retval = -EINVAL;
		break;
	}
	if ((retval > 0) && copy_to_user(buf, kbuf, retval))
		retval = -EFAULT;
	kfree(kbuf);
	return retval;
}


/*
 * Version-specific methods for the fops structure.  FIXME don't need anymore.
 */
ssize_t short_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	return do_short_read(filp->f_dentry->d_inode, filp, buf, count, f_pos);
}



ssize_t do_short_write (struct inode *inode, struct file *filp, const char __user *buf,
		size_t count, loff_t *f_pos)
{
	int retval = count, minor = iminor(inode);
	unsigned long port = short_base + (minor&0x0f);
	void *address = (void *) short_base + (minor&0x0f);
	int mode = (minor&0x70) >> 4;
	unsigned char *kbuf = kmalloc(count, GFP_KERNEL), *ptr;

	if (!kbuf)
		return -ENOMEM;
	if (copy_from_user(kbuf, buf, count))
		return -EFAULT;
	ptr = kbuf;

	if (use_mem)
		mode = SHORT_MEMORY;

	switch(mode) {
	case SHORT_PAUSE:
		while (count--) {
			outb_p(*(ptr++), port);
			wmb();
		}
		break;

	case SHORT_STRING:
		outsb(port, ptr, count);
		wmb();
		break;

	case SHORT_DEFAULT:
		while (count--) {
			outb(*(ptr++), port);
			wmb();
		}
		break;

	case SHORT_MEMORY:
		while (count--) {
			iowrite8(*ptr++, address);
			wmb();
		}
		break;

	default: /* no more modes defined by now */
		retval = -EINVAL;
		break;
	}
	kfree(kbuf);
	return retval;
}


ssize_t short_write(struct file *filp, const char __user *buf, size_t count,
		loff_t *f_pos)
{
	return do_short_write(filp->f_dentry->d_inode, filp, buf, count, f_pos);
}




unsigned int short_poll(struct file *filp, poll_table *wait)
{
	return POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;
}






struct file_operations short_fops = {
	.owner	 = THIS_MODULE,
	.read	 = short_read,
	.write	 = short_write,
	.poll	 = short_poll,
	.open	 = short_open,
	.release = short_release,
};

/* then,  the interrupt-related device */

ssize_t short_i_read (struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
	int count0;
	DEFINE_WAIT(wait);

	while (short_head == short_tail) {
		prepare_to_wait(&short_queue, &wait, TASK_INTERRUPTIBLE);
		if (short_head == short_tail)
			schedule();
		finish_wait(&short_queue, &wait);
		if (signal_pending (current))  /* 某个信号已经到达 */
			return -ERESTARTSYS; /* 告诉fs层做进一步处理 */
	} 
	/* count0 是可读取数据字节数 */
	count0 = short_head - short_tail;
	if (count0 < 0) /* 已交换 */
		count0 = short_buffer + PAGE_SIZE - short_tail;
	if (count0 < count) count = count0;

	if (copy_to_user(buf, (char *)short_tail, count))
		return -EFAULT;
	short_incr_bp (&short_tail, count);
	return count;
}

ssize_t short_i_write (struct file *filp, const char __user *buf, size_t count,
		loff_t *f_pos)
{
	int written = 0, odd = *f_pos & 1;
	unsigned long port = short_base; /* 输出到并口的数据所寄存器 */
	void *address = (void *) short_base;

	if (use_mem) {
		while (written < count)
			iowrite8(0xff * ((++written + odd) & 1), address);
	} else {
		while (written < count)
			outb(0xff * ((++written + odd) & 1), port);
	}

	*f_pos += count;
	return written;
}




struct file_operations short_i_fops = {
	.owner	 = THIS_MODULE,
	.read	 = short_i_read,
	.write	 = short_i_write,
	.open	 = short_open,
	.release = short_release,
};

irqreturn_t short_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	struct timeval tv;
	int written;

	do_gettimeofday(&tv);

	    /* Write a 16 byte record. Assume PAGE_SIZE is a multiple of 16 */
	written = sprintf((char *)short_head,"%08u.%06u\n",
			(int)(tv.tv_sec % 100000000), (int)(tv.tv_usec));
	BUG_ON(written != 16);
	short_incr_bp(&short_head, written);
	wake_up_interruptible(&short_queue); /* awake any reading process */
	return IRQ_HANDLED;
}

/*
 * The following two functions are equivalent to the previous one,
 * but split in top and bottom half. First, a few needed variables
 */

#define NR_TIMEVAL 512 /* length of the array of time values */

struct timeval tv_data[NR_TIMEVAL]; /* too lazy to allocate it */
volatile struct timeval *tv_head=tv_data;
volatile struct timeval *tv_tail=tv_data;

static struct work_struct short_wq;


int short_wq_count = 0;

/*
 * Increment a circular buffer pointer in a way that nobody sees
 * an intermediate value.
 */
static inline void short_incr_tv(volatile struct timeval **tvp)
{
	if (*tvp == (tv_data + NR_TIMEVAL - 1))
		*tvp = tv_data;	 /* Wrap */
	else
		(*tvp)++;
}



void short_do_tasklet (unsigned long unused)
{
	int savecount = short_wq_count, written;
	short_wq_count = 0; /* 已经从队列中移除 */
	/*
	 底半部读取由顶半部填充的tv数组
	 并向循环数组缓冲区打印信息，而缓冲区的信息则由读取进程获得
	 */

	/*首先调用此bh之前发生的终端数量写入 */
	written = sprintf((char *)short_head,"bh after %6i\n",savecount);
	short_incr_bp(&short_head, written);

	/*
	 * 然后写入时间值 每次写入16字节
	 * 所以它与PAGE_SIZE是对齐的
	 */

	do {
		written = sprintf((char *)short_head,"%08u.%06u\n",
				(int)(tv_tail->tv_sec % 100000000),
				(int)(tv_tail->tv_usec));
		short_incr_bp(&short_head, written);
		short_incr_tv(&tv_tail);
	} while (tv_tail != tv_head);

	wake_up_interruptible(&short_queue); /* 唤醒任何读取进程 */
}


irqreturn_t short_wq_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	/* 获取当前时间信息. */
	do_gettimeofday((struct timeval *) tv_head);
	short_incr_tv(&tv_head);

	/* 排序bh 不必担心多次调度的情况 */
	schedule_work(&short_wq);

	short_wq_count++; /* 记录中断的到达 */
	return IRQ_HANDLED;
}


/*
 * Tasklet top half
 */

irqreturn_t short_tl_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	do_gettimeofday((struct timeval *) tv_head); /* cast to stop 'volatile' warning */
	short_incr_tv(&tv_head);
	tasklet_schedule(&short_tasklet);
	short_wq_count++; /* record that an interrupt arrived */
	return IRQ_HANDLED;
}




irqreturn_t short_sh_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
	int value, written;
	struct timeval tv;

	/* 如果不是short产生的则立即返回 */
	value = inb(short_base);
	if (!(value & 0x80))
		return IRQ_NONE;
	
	/* 清除中断位 */
	outb(value & 0x7F, short_base);

	/* 其余部分没有什么变化 */

	do_gettimeofday(&tv);
	//写入一个16字节的记录。假定PAGE_SIZE是16的倍数
	written = sprintf((char *)short_head,"%08u.%06u\n",
			(int)(tv.tv_sec % 100000000), (int)(tv.tv_usec));
	short_incr_bp(&short_head, written);
	wake_up_interruptible(&short_queue); /* 唤醒任何读取进程 */
	return IRQ_HANDLED;
}

void short_kernelprobe(void)
{
	int count = 0;
	do {
		unsigned long mask;

		mask = probe_irq_on();
		outb_p(0x10,short_base+2); /* 启用中断报告 */
		outb_p(0x00,short_base);   /* 清除该位 */
		outb_p(0xFF,short_base);   /* 设置该位 中断 */
		outb_p(0x00,short_base+2); /* 禁用中断报告 */
		udelay(5);  /* 留给终端探测一些时间 */
		short_irq = probe_irq_off(mask);

		if (short_irq == 0)/* 没有找到? */
		{ 
			printk(KERN_INFO "short: no irq reported by probe\n");
			short_irq = -1;
		}
		/*
		 如果已经有多个中断线被激活，则结果为负值
		 我们应该服务该中断（lpt端口不需要）并再次重试
		 最多重试5次，然后放弃
		 */
	} while (short_irq < 0 && count++ < 5);
	if (short_irq < 0)
	{
		printk("short: probe failed %i times, giving up\n", count);
	}
}

irqreturn_t short_probing(int irq, void *dev_id, struct pt_regs *regs)
{
	if (short_irq == 0)
	{
		short_irq = irq;	/* 找到 */
	}
	if (short_irq != irq)
	{
		short_irq = -irq; /* 出现二义性 */
	}
	return IRQ_HANDLED;
}

/*
irq探测是通过为每个缺少中断处理例程的IRQ设置IRQ_WAITING状态位来完成的
当驱动中断产生时，因为没有注册处理例程，do_IRQ清除该位然后返回。当probe_irq_off被
一个驱动程序调用的时候。只需要搜索那些没有设置IRQ_WAITING位的IRQ
*/
void short_selfprobe(void)
{
	int trials[] = {3, 5, 7, 9, 0};
	int tried[]  = {0, 0, 0, 0, 0};
	int i, count = 0;

	/*
	 为所有的中断线安装探测处理例程
	 记录那些目前空闲的结果（0 成功 -EBUSY）仅仅是为了释放已获得的资源
      */
	for (i = 0; trials[i]; i++)
	{
		tried[i] = request_irq(trials[i], short_probing,
				SA_INTERRUPT, "short probe", NULL);
	}

	do {
		short_irq = 0; /* 什么也未获得 */
		outb_p(0x10,short_base+2); /* 启用中断 */
		outb_p(0x00,short_base);
		outb_p(0xFF,short_base); /* 切换中断位 */
		outb_p(0x00,short_base+2); /* 禁用中断 */
		udelay(5);  /* 留给探测一些时间 */

		/* 处理例程已经设置了相应的值 */
		if (short_irq == 0)/* 没有找到? */
		{ 
			printk(KERN_INFO "short: no irq reported by probe\n");
		}
		/*
		 如果已有多个中断线被激活，则结果为负
		 我们应该服务该中断（lpt端口并不需要）并再次重试
		 最多重试五次
		 */
	} while (short_irq <=0 && count++ < 5);

	/* 在循环结束后 卸载处理例程 */
	for (i = 0; trials[i]; i++)
	{
		if (tried[i] == 0)
		{
			free_irq(trials[i], NULL);
		}
	}

	if (short_irq < 0)
	{
		printk("short: probe failed %i times, giving up\n", count);
	}
}



/* Finally, init and cleanup */

int short_init(void)
{
	int result;

	/*
	 * first, sort out the base/short_base ambiguity: we'd better
	 * use short_base in the code, for clarity, but allow setting
	 * just "base" at load time. Same for "irq".
	 */
	short_base = base;
	short_irq = irq;

	/* Get our needed resources. */
	if (!use_mem)
	{
		//short_base是并口使用i/o地址空间的基地址，向并口的2号寄存器写入可以启用终端报告
		if (! request_region(short_base, SHORT_NR_PORTS, "short"))
		{
			printk(KERN_INFO "short: can't get I/O port address 0x%lx\n",
					short_base);
			return -ENODEV;
		}

	}
	else
	{
		if (! request_mem_region(short_base, SHORT_NR_PORTS, "short"))
		{
			printk(KERN_INFO "short: can't get I/O mem address 0x%lx\n",
					short_base);
			return -ENODEV;
		}

		/* also, ioremap it */
		short_base = (unsigned long) ioremap(short_base, SHORT_NR_PORTS);
		/* Hmm... we should check the return value */
	}
	/* Here we register our device - should not fail thereafter */
	result = register_chrdev(major, "short", &short_fops);
	if (result < 0)
	{
		printk(KERN_INFO "short: can't get major number\n");
		release_region(short_base,SHORT_NR_PORTS);  /* FIXME - use-mem case? */
		return result;
	}
	if (major == 0)
	{
		major = result; /* dynamic */
	}

	short_buffer = __get_free_pages(GFP_KERNEL,0); /* never fails */  /* FIXME */
	short_head = short_tail = short_buffer;

	/*
	 * Fill the workqueue structure, used for the bottom half handler.
	 * The cast is there to prevent warnings about the type of the
	 * (unused) argument.
	 */
	/* 下面这行出现在 short_init() 中 */
	INIT_WORK(&short_wq, (void (*)(void *)) short_do_tasklet, NULL);

	/*
	 * Now we deal with the interrupt: either kernel-based
	 * autodetection, DIY detection or default number
	 */

	if (short_irq < 0 && probe == 1)
	{
		short_kernelprobe();
	}

	if (short_irq < 0 && probe == 2)
	{
		short_selfprobe();
	}

	if (short_irq < 0) /* not yet specified: force the default on */
	{
		switch(short_base)
		{
		    case 0x378:
				short_irq = 7; 
				break;
		    case 0x278:
				short_irq = 2;
				break;
		    case 0x3bc:
				short_irq = 5;
				break;
		}
	}

	/*
	 * If shared has been specified, installed the shared handler
	 * instead of the normal one. Do it first, before a -EBUSY will
	 * force short_irq to -1.
	 */
	if (short_irq >= 0 && share > 0)
	{
		/*
		int request_irq(unsigned int irq, void (*handler)(int irq, void *dev_id, struct pt_regs *regs), unsigned long irqflags, const char * devname, void *dev_id);
		rq是要申请的硬件中断号。在Intel平台，范围0--15。
		handler是向系统登记的中断处理函数。这是一个回调函数，中断发生时，系统调用这个函数，传入的参数包括硬件中断号，device id，寄存器值。dev_id就是下面的request_irq时传递给系统的参数dev_id。
		irqflags是中断处理的一些属性。比较重要的有SA_INTERRUPT，标明中断处理程序是快速处理程序(设置SA_INTERRUPT)还是慢速处理程序(不设置SA_INTERRUPT)。快速处理程序被调用时屏蔽当前处理器上的所有中断，其他处理器仍然可以处理中断。慢速处理程序不屏蔽。还有一个SA_SHIRQ属性，设置了以后运行多个设备共享中断。
		devname 是一个字符串，与该中断相关联的名称，在/proc/interrupt中可看到。
		dev_id在中断共享时会用到。一般设置为这个设备的 device结构本身或者NULL，但在注册共享中断时，此参数不能为NULL。中断处理程序可以用dev_id找到相应的控制这个中断的设备，或者用irq2dev_map找到中断对应的设备。
		*/
		result = request_irq(short_irq, short_sh_interrupt,
				SA_SHIRQ | SA_INTERRUPT,"short",
				short_sh_interrupt);
		if (result)
		{
			printk(KERN_INFO "short: can't get assigned irq %i\n", short_irq);
			short_irq = -1;
		}
		else /* 真正启用中断 假定这是一个并口 */
		{
			outb(0x10, short_base+2);
		}
		return 0; /* the rest of the function only installs handlers */
	}

	if (short_irq >= 0)
	{
		result = request_irq(short_irq, short_interrupt,
				SA_INTERRUPT, "short", NULL);
		if (result)
		{
			printk(KERN_INFO "short: can't get assigned irq %i\n",
					short_irq);
			short_irq = -1;
		}
		else /* 真正启用中断 假定这是一个并口 */
		{ 
			outb(0x10,short_base+2);
		}
	}

	/*
	 * Ok, now change the interrupt handler if using top/bottom halves
	 * has been requested
	 */
	if (short_irq >= 0 && (wq + tasklet) > 0)
	{
		free_irq(short_irq,NULL);
		result = request_irq(short_irq,
				tasklet ? short_tl_interrupt :
				short_wq_interrupt,
				SA_INTERRUPT,"short-bh", NULL);
		if (result)
		{
			printk(KERN_INFO "short-bh: can't get assigned irq %i\n",
					short_irq);
			short_irq = -1;
		}
	}

	return 0;
}

void short_cleanup(void)
{
	if (short_irq >= 0)
	{
		outb(0x0, short_base + 2);   /* disable the interrupt */
		if (!share)
		{
			//void free_irq(unsigned int irq,void *dev_id);
			free_irq(short_irq, NULL);
		}
		else
		{
			free_irq(short_irq, short_sh_interrupt);
		}
	}
	/* Make sure we don't leave work queue/tasklet functions running */
	if (tasklet)
	{
		tasklet_disable(&short_tasklet);
	}
	else
	{
		flush_scheduled_work();
	}
	unregister_chrdev(major, "short");
	if (use_mem)
	{
		iounmap((void __iomem *)short_base);
		release_mem_region(short_base, SHORT_NR_PORTS);
	}
	else 
	{
		release_region(short_base,SHORT_NR_PORTS);
	}
	if (short_buffer)
	{
		free_page(short_buffer);
	}
}

module_init(short_init);
module_exit(short_cleanup);

//request_irq() 给给定的中断源安装中断处理程序
//free_irq()    释放分配给已定中断的内存
//enable_irq()  调用中断控制函数使给定中断链有效
//disable_irq() 使定义中断链失效