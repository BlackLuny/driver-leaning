信号量是睡眠锁。如果一个任务试图获取一个已经被占用的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重新
自由，转而去执行其它代码。当持有信号量的进程将信号量释放后，处于等待队列中的那个任务将被唤醒，并获得该信号量。
信号量的结论
1 由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况
2 相反，锁被短时间持有时，信号量就不太适宜了，因为睡眠，维护等待队列以及唤醒所话费的开销可能比锁被占用的全部时间还要长。
3 由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下文中试不能进行调度的。
4 你可以在持有信号量时去睡眠（当然你也可能不需要睡眠）因为当其他进程试图获得同一信号量时不会死锁（因为该进程也只是去睡眠而已，而你最终会执行的）
5 在你占用信号量的同时不能占用自旋锁，因为在等待信号量的时候可能会睡眠，而在持有自旋锁时是不允许睡眠的
相关函数：
sema_init(struct semaohore*,int)以指定的计数值初始化动态创建的信号量
init_MUTEX(struct semaphore*)以计数值1初始化动态创建的信号量值
init_MUTEX_LOCKED(struct semaphore*)以计数值0初始化动态创建的信号量值（初始化为加锁状态）
down_interruptible(struct semaphore*)以试图获得指定的信号量，如果信号量已被争用，则进入可中断睡眠状态
down(struct semaphore*)以试图获得指定的信号量，如果信号量已被争用，则进入不可中断睡眠状态
down_trylock(struct semaphore*)以试图获得指定的信号量，如果信号量已被争用，则立刻返回非0值
up(struct semaphore*)以释放指定的信号量，如果睡眠队列不为空，则唤醒其中一个任务


自旋锁与信号量比较
低开销加锁	优先自旋锁
短期锁定	优先自旋锁
长期加锁	优先信号量
中断上下文	只能自旋锁
进程上下文	只能信号量

完成变量
init_completion(struct completion *x) 初始化指定的动态创建的完成变量
wait_for_completion(struct completion *) 等待指定完成变量接受信号
complete(struct completion *) 发信号唤醒任何等到任务
