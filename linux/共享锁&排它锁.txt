共享锁（S锁）：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。
排他锁（X锁）：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

读写信号量和读写自旋锁

seq锁
顺序锁也是对读写锁的一种优化，对于顺序锁，读者绝不会被写者阻塞，也就说，读者可以在写者对被顺序锁保护的共享资源进行写操作时仍然可以继续读，而不必等待写者完成写操作，写者也不需要等待所有读者完成读操作才去进行写操作。但是，写者与写者之间仍然是互斥的，即如果有写者在进行写操作，其他写者必须自旋在那里，直到写者释放了顺序锁。
这种锁有一个限制，它必须要求被保护的共享资源不含有指针，因为写者可能使得指针失效，但读者如果正要访问该指针，将导致OOPs。
如果读者在读操作期间，写者已经发生了写操作，那么，读者必须重新读取数据，以便确保得到的数据是完整的。
这种锁对于读写同时进行的概率比较小的情况，性能是非常好的，而且它允许读写同时进行，因而更大地提高了并发性。

seqlock_t mr_seq_lock = SEQLOCK_UNLOCKED;
然后，写锁的方式如下：
write_seqlock(&mr_seq_lock);
//写锁被获取
write_sequnlock(&mr_seq_lock);
和普通自旋锁类似

unsigned long seq;
do
{
	读者在对被顺序锁mr_seq_lock保护的共享资源进行访问前需要调用该函数。读者实际没有任何得到锁和释放锁的开销，该函数只是返回顺序锁mr_seq_lock的当前顺序号。
	seq = read_seqbegin(&mr_seq_lock);
	//读这里的数据
	读者在访问完被顺序锁mr_seq_lock保护的共享资源后需要调用该函数来检查，在读访问期间是否有写者访问了该共享资源，
	如果是，读者就需要重新进行读操作，否则，读者成功完成了读操作
}while(read_seqretry(&mr_seq_lock, seq));
